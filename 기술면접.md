# 기술면접 내용 정리

## 1.데이터베이스 설계 경험
### 사용 기술 : DB설계 과목 프로젝트로 진행 HTML, CSS, MySQL, PHP사용
### 역할 : MySQL을 이용한 데이터베이스 설계 & SQL작성, 동기부여
### 핵심기능 : 직무별 기능 제한 및 업무에 필요한 데이터 조작 기능제공
--------------------------------------------
*HTML이란?*<br>
: 웹사이트를 만든느 가장 기초인 마크업 언어, 웹페이지의 내용과 구조를 담당, 브라우저에게 정보를 어떤 형태로 보여줘야하는지를 전달하는 역할<br/>
*PHP란?*<br>
: HTML코드를 프로그래밍적으로 생성, 서버측에서 주로 사용하는 스크립트언어<br>
>스크립트 언어란? : 어떤 요청이 발생할 때마다 코드 내에서 차례로 실행해야 하는 프로세스들을 자동화하는데 사용되는 코딩언어의 종류.<br/>

장점 : 웹 최적화, 크로스플랫폼, 다양한DB 지원, 동적인 웹페이지 생성가능.<br>
> 서버측 언어를 왜 사용하는가 ? : <a href = https://opentutorials.org/course/3018/5117> 여기 </a><br>

*RDBMS와 NOSQL의 차이* <br>
* 관계형 데이터 베이스 : 정해진 데이터스키마를 따라 DB 테이블에 저장 -> 데이터 무결성 보장, 데이터를 관계를 통해 여러개의 테이블로 분산.<br>
장점 : 데이터의 무결성 보장. 관계로 각 데이터 중복 X.<br>
단점 : 유연성X, 수평확장 어려움, JOIN문 많아서 SQL복잡<br>
=> 데이터의 변경이 자주있을때 사용하는게 유리<br>
* 비관계형 데이터 베이스 : 관계형 데이터 모델을 지양=> 분산된 데이터를 저장하고 조회하는데 특화, 스키마없거나 느슨함, 관계 X<br>
장점 : 유연하다. 읽기속도 빠름. 수평 확장 가능(DB서를 확장해 데이터를 분산시킴)<br>
단점 : 데이터가 여러 컬렉션에 중복되어 있어, 수정해야하는 모든 컬렉션에서 수행.<br>
=> 정확한 데이터 구조를 알 수 없거나. 읽기가 많고 업데이트가 적을때 사용.<br>

## 2. 어플리케이션 개발 경험
### 사용 기술 : React Native, Node JS, MySQL
### 역할 : 검색 키워드를 활용한 채팅 그룹 검색 및 생성, 채팅 기능 관련 DB 설계 및 SQL작성, REST API 설계 연결다리
### 핵심기능 : 유저 인증 및 관리, Text기반 채팅기능, 검색 키워드를 활용한 채팅 그룹 검색 및 생성, 실시간 매칭 게시판
--------------------------------------------------------------------------------
*React Native란?*<br>
: 리액트의 접근방법을 모바일로 확장한 페이스북 오픈소스 프로젝트, JS 코딩한 React 컴포넌트는 RN 플랫폼을 거쳐 모바일 플랫폼 Native 코드로 각각 변환.<br>
> 컴포넌트란? 기능을 단위별로 나눠놓은 단위 <br>

장점 :  JS하나로 작성가능, 개발속도 빠름, 웹으로 확장 용이

*Node JS란?*<br>
: 서버사이드 자바스크립트이며 구글의 자바스크립트 엔진인 V8을 기반으로 구성된 일종의 소프트웨어 시스템. Non-blocking I/O, 단일 스레드 이벤트 루프를 통한 비동기 메시지 처리.<br>
장점 : JS이용해 서버단 로직처리. Non-blocking I/O & 단일 스레드 이벤트 루프를 통한 높은 처리성능.<br>
단점 : 비동기 방식이라 callback지옥에 빠질 수 있음. 단일 쓰레드 방식이기 때문에 하나의 작업이 오래걸리면 비효율적일 수 있음.<br>
로직이 간단하고, 대용량의 처리, 빠른 응답시간 및 개발시간 요구, 비동기방식에 어울리는 서비스에 사용하는게 적합.<br>
> REST 란? HTTP URI를 통해 자원을 명시하고  HTTP Method를 통해 자원에 CRUD 연산을 적용하는 것을 의미.
* HTTP Method : POST(생성) GET(조회) PUT(수정) DELETE(삭제) HEAD(정보조회)<br>
* REST의 장점 : HTTP 프로토콜 인프라 그대로 사용, 사람이 의미를 파악하기 쉽다, 서버와 클라이언트의 역할을 명확하게 분리.<br>
* REST의 단점 : 표준이 없다, 연산이 제한적이다<br>
* REST의 특징 : 서버-클라이언트 구조, Stateless, Cacheable, Layered System.<br>
> REST API란? REST 기반으로 서비스 API구현(API = 데이터와 기능의 집합을 제공해, 프로그램간 상호작용 촉진, 서로 정보를 교환 가능하도록함)<br>
* REST API 설계 원칙 <a href = https://gmlwjd9405.github.io/2018/09/21/rest-and-restful.html>여기 참조 </a>
> RESTful이란? REST원리를 따라는 시스템을 RESTful이라고 지칭한다.

# 상식 정리
-------------------------------
## OOP
* 정의 : 프로그래밍 패러다임의 하나로, 프로그래밍에 필요한 Data와 메소드들을 객채라는 단위로 만들고 이 객채간의 상호작용을 통해 프로그래밍 하는 기법.<br>
* 장점 : 유연하다, 유지보수가 편하다, 직관적으로 읽을 수 있다. => 강한 응집력과 약한 결합력을 지향<br>
* 단점 : 작성하는데 시간이 오래걸린다.<br>
* 기본 구성요소 : 
1. 클래스(유사한 특징을 가진 객체의 변수, 메소드의 집합)
2. 객체(클래스의 인스턴스)
3. 메소드(클래스로부터 생성된 객체를 사용하는 방법).<br>
* 특징 : 
1. 캡슐화(정보은닉의 개념을 이용해 객체의 데이터를 외부에서 쉽게 접근하는 것을 막고, 함수를 통해서 조작이 가능하도록 하는것)
2. 추상화(공통의 특성을 파악하고 불필요한 특성들을 제거하는 과정)
3. 재사용성
## DB
### Index
* 정의 : 데이터베이스의 검색의 효율을 위해 <키 값, 포인터>와 같이 쌍을 이루고 있는 객체, B-tree & B+tree & Hash 인덱스를 많이 이용해서 구현.<br>
> B-tree : 모든 노드에 데이터 저장가능, 트리높이가 높음, 풀스캔 시 모든 노드 탐색, 키 중복 X, 균형 트리       
> B+tree : 리프 노드에만 데이터 저장 가능, 트리높이가 낮음(한 노드에 많은 키 저장가능), 키 중복 O, 균형 트리 <a href = https://zorba91.tistory.com/293> 여기 참고 </a>
> !!인덱스 생성시 b-tree를 많이 사용하는 이유
: hash가 O(1)이지만, WHERE에서 <>(부등호)연산이 자주 일어나는데 이때, Hash방식은 문제가 발생할 수 있음.
* 장점 : SELECT문의 성능이 빨라진다.
* 단점 : Index를 구성하기 위해 추가정인 저장공간이 필요하다. 데이터의 변화가 빈번하게 일어나면 오히려 성능이 저하될 수 있다.
* 적용기준<br>
1. 카디널리티가 높은 컬럼(중복도가 낮은 컬럼)
2. 선택도가 낮은 컬럼(5%~10%)
3. 활용도가 높음.
* 인덱스의 종류 <a href = https://lng1982.tistory.com/144>여기 참고 </a>
1. 클러스터드 인덱스 : 지정한 열에 대해서 값이 물리적으로 자동 정렬되어있다. EX)ABCD.... , 테이블당 한개만 생성가능,leaf level의 테이블이 필요없어 저장공간 덜 차지한다.
2. 넌클러스터드 인덱스 : 물리적으로 자동 정렬을 하지않는다. 별도의 공간에 인덱스 테이블을 만들어 저장한다 -> 저장공간이 많이 필요하다.
### 정규화
* 정규화란? : RDB에서 중복을 최소화하기 위해 데이터를 구조화 하는 작업.<br>
> 왜 최소화를 해야할까? 하나의 릴레이션에 여러 엔티티의 애트리뷰트들이 혼합되면 정보가 중복되며, 저장공간을 낭비 & 여러 이상들이 발생한다.
* 정규화 대상 파악 : 엔티티를 구성하는 애트리뷰트간의 함수적 종속성을 판단한다.
* 각 정규형은 다음과 같은 조건을 만족해야 한다.
1. 분해의 대상인 분해 집합 D는 무손실 조인을 보장해야한다.
2. 분해 집합D는 함수적 종속성을 보존해야한다.
* 장점 : DB변경 시 이상 현상제거, DB 구조 확장 시 연동된 응용 프로그램에 영향 최소화, 이해하기 쉬움.
* 단점 : 릴레이션의 분해로 인해 Join연산이 많아 진다.
*언제 반 규화를 해야할까?*<br>
: 반정규화는 정규화덴 엔티티, 속성, 관계등을 성능 향상 및 운용의 목적으로 중복 통합, 분리 등을 수행하는 데이터 모델링 기법이므로 => 조회를 하는 SQL문장에서 Join이 많이 발생해서 성능저하가 일어날때 수행<br>
### 트랜잭션
* 정의 : DB의 상태를 변환시키는 논리적인 기능을 수행하기 위한 작업 단위, 작업의 완전성을 보장해준다.
* 특성
1. 원자성 : 연산이 모두 반영되거나 모두 반영되지 않아야 한다.
2. 일관성 : 트랜잭션 수행이 성공적으로 완료되었으면, 언제나 일관성 있는 DB상태로 변환한다.
3. 독립성 : 병행 트랜잭션이 수행될 때 다른 트랜잭션에 영향을 주면 안된다.
4. 영속성 : 성공적인 트랜잭션의 결과는 영구적으로 반영되어야 한다.
* 연산 : Commit(한개의 논리적 단위에 대한 작업이 성공) Rollback(트랜잭션의 처리가 비정상적으로 종료되어 이전 정상 상태로 돌아감)
* 상태
1. 활동(트랜잭션 실행 중)
2. 실패(오류가 발생해 중단)
3. 철회(오류가 발생해 Rollback)
4. 부분 완료 (트랜잭션이 마지막 연산까지 실행)
5. 완료 (부분 완료 상태에서 Commit)
* 교착상태 : 복수의 트랜잭션이 특정 자원의 잠금을 하고 다른 트랜잭션이 소유하고 있는 잠금을 요구하는 상황.
> 교착상태의 빈도를 낮추기 => Commit을 자주한다, 정해진 순서로 테이블에 접근한다, 읽기 잠금 획득의 사용 지양.
### 조인
* 정의 : 여러 테이블을 조합 또는 결합하여 데이터를 출력
* 필요성 : 정규화를 통해 서로 관계가 있는 테이블이 여러 테이블로 나눠져 있으므로.
* 종류
  * 내부조인 : 조인하고자 하는 두개의 테이블에서 공통된 요소를 통해 결합하는 방식, 조인결과 새로운 테이블이 생성. => 서로 연관된 내용 검색
      * 동등조인 : = 연산으로반 비교
      * 자연조인 : 조인 결과 공통된 요소를 한번만 출력
      * 교차조인 : 조인되는 두 테이블에서 곱집합을 반환?
  * 외부조인 : 조인 대상 테이블에서 특정 테이블의 데이터가 모두 필요한 상황에 사용 => 조인 조건을 만족하지 않아도 출력
    * 왼쪽 외부 조인 : 왼쪽의 테이블의 모든 데이터를 가져오고 오른쪽과 연관이 없을때 NULL을 표시
    * 오른쪽 외부 조인 : 오른쪽 테이블의 모든 데이터를 가져오고 왼쪽과 연관이 없을때 NULL을 표시
    * 완전 외부 조인
  * 셀프 조인 : 자기 자신과 조인
    
## 자료구조
### 배열
: 같은 타입의 데이터를 나열한 선형 자료구조, 연속된 메모리 공간 차지, 배열의 크기는 고정   
* 장점 : Index를 이용한 접근, 연속된 메모리 공간에 존재해 관리가 편하다.    
* 단점 : 삽입, 삭제가 오래걸림, 배열의 크기가 고정, 연속된 메모리는 공간 낭비 발생가능.   
* 사용시기 : 데이터의 갯수가 정해져있을때, 데이터의 삽입 & 삭제가 적을때, 검색   
### 리스트(Linked List)   
: 포인터를 이용해 데이터를 순차적으로 저장하는 선형 자료구조, 불연속적 메모리 공간에 저장, 노드를 연결하여 만든다, 크기 고정X, 인덱스 접근 불가능   
* 장점 : 삽입과 삭제 용이, 동적으로 생성(크기가 정하지 않음), 연속적인 메모리 공간X(공간 효율적)   
* 단점 : 임의 접근 불가능(인덱스 접근X) => 반복자 사용 탐색이라 시간 오래걸림, 포인터로 인한 저장공간 낭비   
* 사용시기 : 크기가 정해져있지 않을때, 삽입과 삭제가 많을때, 검색을 자주 안할때
### 해쉬
: 연관배열 구조를 이용해 키에 결과값을 저장하는 자료구조   
> 연관배열 구조란? 키와 값이 1:1로 연관되에 있는 자료구조 . 키를 이용해 값을 도출할 수 있다.   
* 구성 요소
  * 키 : 고유한 값, 해시함수의 Input. 다양한 길이
  * 해시함수 : 키를 해시로 바꿔주는 역할, 다양한 길이의 키를 고정길이의 해쉬로 바꾸면 저장공간 효율 상승, 해시충돌 중여야함.
  * 해시 : 해시함수의 결과물, 저장소에 값과 매칭되어 저장됨.   
  * 값 : 저장소에 최종적으로 저장되는 값, 삭제&검색&접근이 가능해야한다.   
* 단점 : 순서가 있는 배열에는 어울리지 않음, 공간 효율성 낮음, 해시 함수 의존도 높음.   
ff
